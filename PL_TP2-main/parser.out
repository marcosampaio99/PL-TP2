Created by PLY version 3.7 (http://www.dabeaz.com/ply)

Unused terminals:

    VOID
    NEQ
    OR
    INT

Grammar

Rule 0     S' -> main
Rule 1     main -> MAIN instrs END
Rule 2     instrs -> instrs instr
Rule 3     instrs -> instr
Rule 4     instr -> atr endline
Rule 5     instr -> write endline
Rule 6     instr -> read endline
Rule 7     instr -> endline
Rule 8     instr -> cond
Rule 9     instr -> cycle
Rule 10    instr -> lexpr
Rule 11    instr -> <empty>
Rule 12    endline -> ;
Rule 13    cond -> IF ( lexpr ) START instrs START ELSE START instrs END
Rule 14    cycle -> REPEATE START { instrs } UNTIL ( instrs ) END
Rule 15    write -> WRITE ID
Rule 16    write -> WRITE STR
Rule 17    atr -> ID = expr
Rule 18    read -> READ ID
Rule 19    lexpr -> lexpr AND lexpr
Rule 20    lexpr -> expr EQ expr
Rule 21    lexpr -> expr LE expr
Rule 22    lexpr -> expr GE expr
Rule 23    lexpr -> expr > expr
Rule 24    lexpr -> expr < expr
Rule 25    lexpr -> expr
Rule 26    lexpr -> ( lexpr )
Rule 27    expr -> expr + expr
Rule 28    expr -> expr - expr
Rule 29    expr -> term
Rule 30    term -> term * par
Rule 31    term -> term / par
Rule 32    term -> term % par
Rule 33    term -> term AND par
Rule 34    term -> par
Rule 35    par -> ( expr )
Rule 36    par -> NUM
Rule 37    par -> ID
Rule 38    par -> NOT lexpr

Terminals, with rules where they appear

%                    : 32
(                    : 13 14 26 35
)                    : 13 14 26 35
*                    : 30
+                    : 27
-                    : 28
/                    : 31
;                    : 12
<                    : 24
=                    : 17
>                    : 23
AND                  : 19 33
ELSE                 : 13
END                  : 1 13 14
EQ                   : 20
GE                   : 22
ID                   : 15 17 18 37
IF                   : 13
INT                  : 
LE                   : 21
MAIN                 : 1
NEQ                  : 
NOT                  : 38
NUM                  : 36
OR                   : 
READ                 : 18
REPEATE              : 14
START                : 13 13 13 14
STR                  : 16
UNTIL                : 14
VOID                 : 
WRITE                : 15 16
error                : 
{                    : 14
}                    : 14

Nonterminals, with rules where they appear

atr                  : 4
cond                 : 8
cycle                : 9
endline              : 4 5 6 7
expr                 : 17 20 20 21 21 22 22 23 23 24 24 25 27 27 28 28 35
instr                : 2 3
instrs               : 1 2 13 13 14 14
lexpr                : 10 13 19 19 26 38
main                 : 0
par                  : 30 31 32 33 34
read                 : 6
term                 : 29 30 31 32 33
write                : 5

Parsing method: LALR

state 0

    (0) S' -> . main
    (1) main -> . MAIN instrs END

    MAIN            shift and go to state 2

    main                           shift and go to state 1

state 1

    (0) S' -> main .



state 2

    (1) main -> MAIN . instrs END
    (2) instrs -> . instrs instr
    (3) instrs -> . instr
    (4) instr -> . atr endline
    (5) instr -> . write endline
    (6) instr -> . read endline
    (7) instr -> . endline
    (8) instr -> . cond
    (9) instr -> . cycle
    (10) instr -> . lexpr
    (11) instr -> .
    (17) atr -> . ID = expr
    (15) write -> . WRITE ID
    (16) write -> . WRITE STR
    (18) read -> . READ ID
    (12) endline -> . ;
    (13) cond -> . IF ( lexpr ) START instrs START ELSE START instrs END
    (14) cycle -> . REPEATE START { instrs } UNTIL ( instrs ) END
    (19) lexpr -> . lexpr AND lexpr
    (20) lexpr -> . expr EQ expr
    (21) lexpr -> . expr LE expr
    (22) lexpr -> . expr GE expr
    (23) lexpr -> . expr > expr
    (24) lexpr -> . expr < expr
    (25) lexpr -> . expr
    (26) lexpr -> . ( lexpr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEATE resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    END             reduce using rule 11 (instr -> .)
    ID              shift and go to state 6
    WRITE           shift and go to state 22
    READ            shift and go to state 19
    ;               shift and go to state 18
    IF              shift and go to state 5
    REPEATE         shift and go to state 21
    (               shift and go to state 12
    NUM             shift and go to state 9
    NOT             shift and go to state 3

  ! ID              [ reduce using rule 11 (instr -> .) ]
  ! WRITE           [ reduce using rule 11 (instr -> .) ]
  ! READ            [ reduce using rule 11 (instr -> .) ]
  ! ;               [ reduce using rule 11 (instr -> .) ]
  ! IF              [ reduce using rule 11 (instr -> .) ]
  ! REPEATE         [ reduce using rule 11 (instr -> .) ]
  ! (               [ reduce using rule 11 (instr -> .) ]
  ! NUM             [ reduce using rule 11 (instr -> .) ]
  ! NOT             [ reduce using rule 11 (instr -> .) ]

    par                            shift and go to state 4
    endline                        shift and go to state 20
    instrs                         shift and go to state 16
    cycle                          shift and go to state 17
    lexpr                          shift and go to state 7
    atr                            shift and go to state 8
    cond                           shift and go to state 10
    expr                           shift and go to state 13
    write                          shift and go to state 23
    read                           shift and go to state 11
    instr                          shift and go to state 14
    term                           shift and go to state 15

state 3

    (38) par -> NOT . lexpr
    (19) lexpr -> . lexpr AND lexpr
    (20) lexpr -> . expr EQ expr
    (21) lexpr -> . expr LE expr
    (22) lexpr -> . expr GE expr
    (23) lexpr -> . expr > expr
    (24) lexpr -> . expr < expr
    (25) lexpr -> . expr
    (26) lexpr -> . ( lexpr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 12
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    lexpr                          shift and go to state 24
    expr                           shift and go to state 13
    par                            shift and go to state 4
    term                           shift and go to state 15

state 4

    (34) term -> par .

    AND             reduce using rule 34 (term -> par .)
    *               reduce using rule 34 (term -> par .)
    /               reduce using rule 34 (term -> par .)
    %               reduce using rule 34 (term -> par .)
    EQ              reduce using rule 34 (term -> par .)
    LE              reduce using rule 34 (term -> par .)
    GE              reduce using rule 34 (term -> par .)
    >               reduce using rule 34 (term -> par .)
    <               reduce using rule 34 (term -> par .)
    +               reduce using rule 34 (term -> par .)
    -               reduce using rule 34 (term -> par .)
    END             reduce using rule 34 (term -> par .)
    ID              reduce using rule 34 (term -> par .)
    WRITE           reduce using rule 34 (term -> par .)
    READ            reduce using rule 34 (term -> par .)
    ;               reduce using rule 34 (term -> par .)
    IF              reduce using rule 34 (term -> par .)
    REPEATE         reduce using rule 34 (term -> par .)
    (               reduce using rule 34 (term -> par .)
    NUM             reduce using rule 34 (term -> par .)
    NOT             reduce using rule 34 (term -> par .)
    )               reduce using rule 34 (term -> par .)
    }               reduce using rule 34 (term -> par .)
    START           reduce using rule 34 (term -> par .)


state 5

    (13) cond -> IF . ( lexpr ) START instrs START ELSE START instrs END

    (               shift and go to state 26


state 6

    (17) atr -> ID . = expr
    (37) par -> ID .

    =               shift and go to state 27
    *               reduce using rule 37 (par -> ID .)
    /               reduce using rule 37 (par -> ID .)
    %               reduce using rule 37 (par -> ID .)
    AND             reduce using rule 37 (par -> ID .)
    EQ              reduce using rule 37 (par -> ID .)
    LE              reduce using rule 37 (par -> ID .)
    GE              reduce using rule 37 (par -> ID .)
    >               reduce using rule 37 (par -> ID .)
    <               reduce using rule 37 (par -> ID .)
    +               reduce using rule 37 (par -> ID .)
    -               reduce using rule 37 (par -> ID .)
    )               reduce using rule 37 (par -> ID .)
    ID              reduce using rule 37 (par -> ID .)
    WRITE           reduce using rule 37 (par -> ID .)
    READ            reduce using rule 37 (par -> ID .)
    ;               reduce using rule 37 (par -> ID .)
    IF              reduce using rule 37 (par -> ID .)
    REPEATE         reduce using rule 37 (par -> ID .)
    (               reduce using rule 37 (par -> ID .)
    NUM             reduce using rule 37 (par -> ID .)
    NOT             reduce using rule 37 (par -> ID .)
    START           reduce using rule 37 (par -> ID .)
    END             reduce using rule 37 (par -> ID .)
    }               reduce using rule 37 (par -> ID .)


state 7

    (10) instr -> lexpr .
    (19) lexpr -> lexpr . AND lexpr

    }               reduce using rule 10 (instr -> lexpr .)
    ID              reduce using rule 10 (instr -> lexpr .)
    WRITE           reduce using rule 10 (instr -> lexpr .)
    READ            reduce using rule 10 (instr -> lexpr .)
    ;               reduce using rule 10 (instr -> lexpr .)
    IF              reduce using rule 10 (instr -> lexpr .)
    REPEATE         reduce using rule 10 (instr -> lexpr .)
    (               reduce using rule 10 (instr -> lexpr .)
    NUM             reduce using rule 10 (instr -> lexpr .)
    NOT             reduce using rule 10 (instr -> lexpr .)
    END             reduce using rule 10 (instr -> lexpr .)
    START           reduce using rule 10 (instr -> lexpr .)
    )               reduce using rule 10 (instr -> lexpr .)
    AND             shift and go to state 28


state 8

    (4) instr -> atr . endline
    (12) endline -> . ;

    ;               shift and go to state 18

    endline                        shift and go to state 29

state 9

    (36) par -> NUM .

    *               reduce using rule 36 (par -> NUM .)
    /               reduce using rule 36 (par -> NUM .)
    %               reduce using rule 36 (par -> NUM .)
    AND             reduce using rule 36 (par -> NUM .)
    EQ              reduce using rule 36 (par -> NUM .)
    LE              reduce using rule 36 (par -> NUM .)
    GE              reduce using rule 36 (par -> NUM .)
    >               reduce using rule 36 (par -> NUM .)
    <               reduce using rule 36 (par -> NUM .)
    +               reduce using rule 36 (par -> NUM .)
    -               reduce using rule 36 (par -> NUM .)
    )               reduce using rule 36 (par -> NUM .)
    ID              reduce using rule 36 (par -> NUM .)
    WRITE           reduce using rule 36 (par -> NUM .)
    READ            reduce using rule 36 (par -> NUM .)
    ;               reduce using rule 36 (par -> NUM .)
    IF              reduce using rule 36 (par -> NUM .)
    REPEATE         reduce using rule 36 (par -> NUM .)
    (               reduce using rule 36 (par -> NUM .)
    NUM             reduce using rule 36 (par -> NUM .)
    NOT             reduce using rule 36 (par -> NUM .)
    END             reduce using rule 36 (par -> NUM .)
    }               reduce using rule 36 (par -> NUM .)
    START           reduce using rule 36 (par -> NUM .)


state 10

    (8) instr -> cond .

    }               reduce using rule 8 (instr -> cond .)
    ID              reduce using rule 8 (instr -> cond .)
    WRITE           reduce using rule 8 (instr -> cond .)
    READ            reduce using rule 8 (instr -> cond .)
    ;               reduce using rule 8 (instr -> cond .)
    IF              reduce using rule 8 (instr -> cond .)
    REPEATE         reduce using rule 8 (instr -> cond .)
    (               reduce using rule 8 (instr -> cond .)
    NUM             reduce using rule 8 (instr -> cond .)
    NOT             reduce using rule 8 (instr -> cond .)
    END             reduce using rule 8 (instr -> cond .)
    START           reduce using rule 8 (instr -> cond .)
    )               reduce using rule 8 (instr -> cond .)


state 11

    (6) instr -> read . endline
    (12) endline -> . ;

    ;               shift and go to state 18

    endline                        shift and go to state 30

state 12

    (26) lexpr -> ( . lexpr )
    (35) par -> ( . expr )
    (19) lexpr -> . lexpr AND lexpr
    (20) lexpr -> . expr EQ expr
    (21) lexpr -> . expr LE expr
    (22) lexpr -> . expr GE expr
    (23) lexpr -> . expr > expr
    (24) lexpr -> . expr < expr
    (25) lexpr -> . expr
    (26) lexpr -> . ( lexpr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 12
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    lexpr                          shift and go to state 31
    expr                           shift and go to state 32
    par                            shift and go to state 4
    term                           shift and go to state 15

state 13

    (20) lexpr -> expr . EQ expr
    (21) lexpr -> expr . LE expr
    (22) lexpr -> expr . GE expr
    (23) lexpr -> expr . > expr
    (24) lexpr -> expr . < expr
    (25) lexpr -> expr .
    (27) expr -> expr . + expr
    (28) expr -> expr . - expr

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
    EQ              shift and go to state 39
    LE              shift and go to state 37
    GE              shift and go to state 35
    >               shift and go to state 38
    <               shift and go to state 33
    AND             reduce using rule 25 (lexpr -> expr .)
    }               reduce using rule 25 (lexpr -> expr .)
    ID              reduce using rule 25 (lexpr -> expr .)
    WRITE           reduce using rule 25 (lexpr -> expr .)
    READ            reduce using rule 25 (lexpr -> expr .)
    ;               reduce using rule 25 (lexpr -> expr .)
    IF              reduce using rule 25 (lexpr -> expr .)
    REPEATE         reduce using rule 25 (lexpr -> expr .)
    (               reduce using rule 25 (lexpr -> expr .)
    NUM             reduce using rule 25 (lexpr -> expr .)
    NOT             reduce using rule 25 (lexpr -> expr .)
    START           reduce using rule 25 (lexpr -> expr .)
    END             reduce using rule 25 (lexpr -> expr .)
    )               reduce using rule 25 (lexpr -> expr .)
    *               reduce using rule 25 (lexpr -> expr .)
    /               reduce using rule 25 (lexpr -> expr .)
    %               reduce using rule 25 (lexpr -> expr .)
    +               shift and go to state 34
    -               shift and go to state 36

  ! EQ              [ reduce using rule 25 (lexpr -> expr .) ]
  ! LE              [ reduce using rule 25 (lexpr -> expr .) ]
  ! GE              [ reduce using rule 25 (lexpr -> expr .) ]
  ! >               [ reduce using rule 25 (lexpr -> expr .) ]
  ! <               [ reduce using rule 25 (lexpr -> expr .) ]
  ! +               [ reduce using rule 25 (lexpr -> expr .) ]
  ! -               [ reduce using rule 25 (lexpr -> expr .) ]


state 14

    (3) instrs -> instr .

    }               reduce using rule 3 (instrs -> instr .)
    ID              reduce using rule 3 (instrs -> instr .)
    WRITE           reduce using rule 3 (instrs -> instr .)
    READ            reduce using rule 3 (instrs -> instr .)
    ;               reduce using rule 3 (instrs -> instr .)
    IF              reduce using rule 3 (instrs -> instr .)
    REPEATE         reduce using rule 3 (instrs -> instr .)
    (               reduce using rule 3 (instrs -> instr .)
    NUM             reduce using rule 3 (instrs -> instr .)
    NOT             reduce using rule 3 (instrs -> instr .)
    END             reduce using rule 3 (instrs -> instr .)
    )               reduce using rule 3 (instrs -> instr .)
    START           reduce using rule 3 (instrs -> instr .)


state 15

    (29) expr -> term .
    (30) term -> term . * par
    (31) term -> term . / par
    (32) term -> term . % par
    (33) term -> term . AND par

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for AND resolved as shift
    EQ              reduce using rule 29 (expr -> term .)
    LE              reduce using rule 29 (expr -> term .)
    GE              reduce using rule 29 (expr -> term .)
    >               reduce using rule 29 (expr -> term .)
    <               reduce using rule 29 (expr -> term .)
    +               reduce using rule 29 (expr -> term .)
    -               reduce using rule 29 (expr -> term .)
    )               reduce using rule 29 (expr -> term .)
    END             reduce using rule 29 (expr -> term .)
    ID              reduce using rule 29 (expr -> term .)
    WRITE           reduce using rule 29 (expr -> term .)
    READ            reduce using rule 29 (expr -> term .)
    ;               reduce using rule 29 (expr -> term .)
    IF              reduce using rule 29 (expr -> term .)
    REPEATE         reduce using rule 29 (expr -> term .)
    (               reduce using rule 29 (expr -> term .)
    NUM             reduce using rule 29 (expr -> term .)
    NOT             reduce using rule 29 (expr -> term .)
    }               reduce using rule 29 (expr -> term .)
    START           reduce using rule 29 (expr -> term .)
    *               shift and go to state 40
    /               shift and go to state 42
    %               shift and go to state 41
    AND             shift and go to state 43

  ! AND             [ reduce using rule 29 (expr -> term .) ]
  ! *               [ reduce using rule 29 (expr -> term .) ]
  ! /               [ reduce using rule 29 (expr -> term .) ]
  ! %               [ reduce using rule 29 (expr -> term .) ]


state 16

    (1) main -> MAIN instrs . END
    (2) instrs -> instrs . instr
    (4) instr -> . atr endline
    (5) instr -> . write endline
    (6) instr -> . read endline
    (7) instr -> . endline
    (8) instr -> . cond
    (9) instr -> . cycle
    (10) instr -> . lexpr
    (11) instr -> .
    (17) atr -> . ID = expr
    (15) write -> . WRITE ID
    (16) write -> . WRITE STR
    (18) read -> . READ ID
    (12) endline -> . ;
    (13) cond -> . IF ( lexpr ) START instrs START ELSE START instrs END
    (14) cycle -> . REPEATE START { instrs } UNTIL ( instrs ) END
    (19) lexpr -> . lexpr AND lexpr
    (20) lexpr -> . expr EQ expr
    (21) lexpr -> . expr LE expr
    (22) lexpr -> . expr GE expr
    (23) lexpr -> . expr > expr
    (24) lexpr -> . expr < expr
    (25) lexpr -> . expr
    (26) lexpr -> . ( lexpr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

  ! shift/reduce conflict for END resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEATE resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    END             shift and go to state 45
    ID              shift and go to state 6
    WRITE           shift and go to state 22
    READ            shift and go to state 19
    ;               shift and go to state 18
    IF              shift and go to state 5
    REPEATE         shift and go to state 21
    (               shift and go to state 12
    NUM             shift and go to state 9
    NOT             shift and go to state 3

  ! END             [ reduce using rule 11 (instr -> .) ]
  ! ID              [ reduce using rule 11 (instr -> .) ]
  ! WRITE           [ reduce using rule 11 (instr -> .) ]
  ! READ            [ reduce using rule 11 (instr -> .) ]
  ! ;               [ reduce using rule 11 (instr -> .) ]
  ! IF              [ reduce using rule 11 (instr -> .) ]
  ! REPEATE         [ reduce using rule 11 (instr -> .) ]
  ! (               [ reduce using rule 11 (instr -> .) ]
  ! NUM             [ reduce using rule 11 (instr -> .) ]
  ! NOT             [ reduce using rule 11 (instr -> .) ]

    par                            shift and go to state 4
    endline                        shift and go to state 20
    cycle                          shift and go to state 17
    lexpr                          shift and go to state 7
    atr                            shift and go to state 8
    cond                           shift and go to state 10
    expr                           shift and go to state 13
    write                          shift and go to state 23
    read                           shift and go to state 11
    instr                          shift and go to state 44
    term                           shift and go to state 15

state 17

    (9) instr -> cycle .

    }               reduce using rule 9 (instr -> cycle .)
    ID              reduce using rule 9 (instr -> cycle .)
    WRITE           reduce using rule 9 (instr -> cycle .)
    READ            reduce using rule 9 (instr -> cycle .)
    ;               reduce using rule 9 (instr -> cycle .)
    IF              reduce using rule 9 (instr -> cycle .)
    REPEATE         reduce using rule 9 (instr -> cycle .)
    (               reduce using rule 9 (instr -> cycle .)
    NUM             reduce using rule 9 (instr -> cycle .)
    NOT             reduce using rule 9 (instr -> cycle .)
    END             reduce using rule 9 (instr -> cycle .)
    START           reduce using rule 9 (instr -> cycle .)
    )               reduce using rule 9 (instr -> cycle .)


state 18

    (12) endline -> ; .

    START           reduce using rule 12 (endline -> ; .)
    ID              reduce using rule 12 (endline -> ; .)
    WRITE           reduce using rule 12 (endline -> ; .)
    READ            reduce using rule 12 (endline -> ; .)
    ;               reduce using rule 12 (endline -> ; .)
    IF              reduce using rule 12 (endline -> ; .)
    REPEATE         reduce using rule 12 (endline -> ; .)
    (               reduce using rule 12 (endline -> ; .)
    NUM             reduce using rule 12 (endline -> ; .)
    NOT             reduce using rule 12 (endline -> ; .)
    END             reduce using rule 12 (endline -> ; .)
    }               reduce using rule 12 (endline -> ; .)
    )               reduce using rule 12 (endline -> ; .)


state 19

    (18) read -> READ . ID

    ID              shift and go to state 46


state 20

    (7) instr -> endline .

    }               reduce using rule 7 (instr -> endline .)
    ID              reduce using rule 7 (instr -> endline .)
    WRITE           reduce using rule 7 (instr -> endline .)
    READ            reduce using rule 7 (instr -> endline .)
    ;               reduce using rule 7 (instr -> endline .)
    IF              reduce using rule 7 (instr -> endline .)
    REPEATE         reduce using rule 7 (instr -> endline .)
    (               reduce using rule 7 (instr -> endline .)
    NUM             reduce using rule 7 (instr -> endline .)
    NOT             reduce using rule 7 (instr -> endline .)
    END             reduce using rule 7 (instr -> endline .)
    START           reduce using rule 7 (instr -> endline .)
    )               reduce using rule 7 (instr -> endline .)


state 21

    (14) cycle -> REPEATE . START { instrs } UNTIL ( instrs ) END

    START           shift and go to state 47


state 22

    (15) write -> WRITE . ID
    (16) write -> WRITE . STR

    ID              shift and go to state 49
    STR             shift and go to state 48


state 23

    (5) instr -> write . endline
    (12) endline -> . ;

    ;               shift and go to state 18

    endline                        shift and go to state 50

state 24

    (38) par -> NOT lexpr .
    (19) lexpr -> lexpr . AND lexpr

  ! shift/reduce conflict for AND resolved as shift
    *               reduce using rule 38 (par -> NOT lexpr .)
    /               reduce using rule 38 (par -> NOT lexpr .)
    %               reduce using rule 38 (par -> NOT lexpr .)
    EQ              reduce using rule 38 (par -> NOT lexpr .)
    LE              reduce using rule 38 (par -> NOT lexpr .)
    GE              reduce using rule 38 (par -> NOT lexpr .)
    >               reduce using rule 38 (par -> NOT lexpr .)
    <               reduce using rule 38 (par -> NOT lexpr .)
    +               reduce using rule 38 (par -> NOT lexpr .)
    -               reduce using rule 38 (par -> NOT lexpr .)
    )               reduce using rule 38 (par -> NOT lexpr .)
    ID              reduce using rule 38 (par -> NOT lexpr .)
    WRITE           reduce using rule 38 (par -> NOT lexpr .)
    READ            reduce using rule 38 (par -> NOT lexpr .)
    ;               reduce using rule 38 (par -> NOT lexpr .)
    IF              reduce using rule 38 (par -> NOT lexpr .)
    REPEATE         reduce using rule 38 (par -> NOT lexpr .)
    (               reduce using rule 38 (par -> NOT lexpr .)
    NUM             reduce using rule 38 (par -> NOT lexpr .)
    NOT             reduce using rule 38 (par -> NOT lexpr .)
    END             reduce using rule 38 (par -> NOT lexpr .)
    }               reduce using rule 38 (par -> NOT lexpr .)
    START           reduce using rule 38 (par -> NOT lexpr .)
    AND             shift and go to state 28

  ! AND             [ reduce using rule 38 (par -> NOT lexpr .) ]


state 25

    (37) par -> ID .

    AND             reduce using rule 37 (par -> ID .)
    *               reduce using rule 37 (par -> ID .)
    /               reduce using rule 37 (par -> ID .)
    %               reduce using rule 37 (par -> ID .)
    EQ              reduce using rule 37 (par -> ID .)
    LE              reduce using rule 37 (par -> ID .)
    GE              reduce using rule 37 (par -> ID .)
    >               reduce using rule 37 (par -> ID .)
    <               reduce using rule 37 (par -> ID .)
    +               reduce using rule 37 (par -> ID .)
    -               reduce using rule 37 (par -> ID .)
    END             reduce using rule 37 (par -> ID .)
    ID              reduce using rule 37 (par -> ID .)
    WRITE           reduce using rule 37 (par -> ID .)
    READ            reduce using rule 37 (par -> ID .)
    ;               reduce using rule 37 (par -> ID .)
    IF              reduce using rule 37 (par -> ID .)
    REPEATE         reduce using rule 37 (par -> ID .)
    (               reduce using rule 37 (par -> ID .)
    NUM             reduce using rule 37 (par -> ID .)
    NOT             reduce using rule 37 (par -> ID .)
    )               reduce using rule 37 (par -> ID .)
    }               reduce using rule 37 (par -> ID .)
    START           reduce using rule 37 (par -> ID .)


state 26

    (13) cond -> IF ( . lexpr ) START instrs START ELSE START instrs END
    (19) lexpr -> . lexpr AND lexpr
    (20) lexpr -> . expr EQ expr
    (21) lexpr -> . expr LE expr
    (22) lexpr -> . expr GE expr
    (23) lexpr -> . expr > expr
    (24) lexpr -> . expr < expr
    (25) lexpr -> . expr
    (26) lexpr -> . ( lexpr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 12
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    lexpr                          shift and go to state 51
    expr                           shift and go to state 13
    par                            shift and go to state 4
    term                           shift and go to state 15

state 27

    (17) atr -> ID = . expr
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 53
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    expr                           shift and go to state 52
    par                            shift and go to state 4
    term                           shift and go to state 15

state 28

    (19) lexpr -> lexpr AND . lexpr
    (19) lexpr -> . lexpr AND lexpr
    (20) lexpr -> . expr EQ expr
    (21) lexpr -> . expr LE expr
    (22) lexpr -> . expr GE expr
    (23) lexpr -> . expr > expr
    (24) lexpr -> . expr < expr
    (25) lexpr -> . expr
    (26) lexpr -> . ( lexpr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 12
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    lexpr                          shift and go to state 54
    expr                           shift and go to state 13
    par                            shift and go to state 4
    term                           shift and go to state 15

state 29

    (4) instr -> atr endline .

    }               reduce using rule 4 (instr -> atr endline .)
    ID              reduce using rule 4 (instr -> atr endline .)
    WRITE           reduce using rule 4 (instr -> atr endline .)
    READ            reduce using rule 4 (instr -> atr endline .)
    ;               reduce using rule 4 (instr -> atr endline .)
    IF              reduce using rule 4 (instr -> atr endline .)
    REPEATE         reduce using rule 4 (instr -> atr endline .)
    (               reduce using rule 4 (instr -> atr endline .)
    NUM             reduce using rule 4 (instr -> atr endline .)
    NOT             reduce using rule 4 (instr -> atr endline .)
    END             reduce using rule 4 (instr -> atr endline .)
    START           reduce using rule 4 (instr -> atr endline .)
    )               reduce using rule 4 (instr -> atr endline .)


state 30

    (6) instr -> read endline .

    }               reduce using rule 6 (instr -> read endline .)
    ID              reduce using rule 6 (instr -> read endline .)
    WRITE           reduce using rule 6 (instr -> read endline .)
    READ            reduce using rule 6 (instr -> read endline .)
    ;               reduce using rule 6 (instr -> read endline .)
    IF              reduce using rule 6 (instr -> read endline .)
    REPEATE         reduce using rule 6 (instr -> read endline .)
    (               reduce using rule 6 (instr -> read endline .)
    NUM             reduce using rule 6 (instr -> read endline .)
    NOT             reduce using rule 6 (instr -> read endline .)
    END             reduce using rule 6 (instr -> read endline .)
    START           reduce using rule 6 (instr -> read endline .)
    )               reduce using rule 6 (instr -> read endline .)


state 31

    (26) lexpr -> ( lexpr . )
    (19) lexpr -> lexpr . AND lexpr

    )               shift and go to state 55
    AND             shift and go to state 28


state 32

    (35) par -> ( expr . )
    (20) lexpr -> expr . EQ expr
    (21) lexpr -> expr . LE expr
    (22) lexpr -> expr . GE expr
    (23) lexpr -> expr . > expr
    (24) lexpr -> expr . < expr
    (25) lexpr -> expr .
    (27) expr -> expr . + expr
    (28) expr -> expr . - expr

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 56
    EQ              shift and go to state 39
    LE              shift and go to state 37
    GE              shift and go to state 35
    >               shift and go to state 38
    <               shift and go to state 33
    AND             reduce using rule 25 (lexpr -> expr .)
    +               shift and go to state 34
    -               shift and go to state 36

  ! )               [ reduce using rule 25 (lexpr -> expr .) ]


state 33

    (24) lexpr -> expr < . expr
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 53
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    expr                           shift and go to state 57
    par                            shift and go to state 4
    term                           shift and go to state 15

state 34

    (27) expr -> expr + . expr
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 53
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    expr                           shift and go to state 58
    par                            shift and go to state 4
    term                           shift and go to state 15

state 35

    (22) lexpr -> expr GE . expr
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 53
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    expr                           shift and go to state 59
    par                            shift and go to state 4
    term                           shift and go to state 15

state 36

    (28) expr -> expr - . expr
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 53
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    expr                           shift and go to state 60
    par                            shift and go to state 4
    term                           shift and go to state 15

state 37

    (21) lexpr -> expr LE . expr
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 53
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    expr                           shift and go to state 61
    par                            shift and go to state 4
    term                           shift and go to state 15

state 38

    (23) lexpr -> expr > . expr
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 53
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    expr                           shift and go to state 62
    par                            shift and go to state 4
    term                           shift and go to state 15

state 39

    (20) lexpr -> expr EQ . expr
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 53
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    expr                           shift and go to state 63
    par                            shift and go to state 4
    term                           shift and go to state 15

state 40

    (30) term -> term * . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 53
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    par                            shift and go to state 64

state 41

    (32) term -> term % . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 53
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    par                            shift and go to state 65

state 42

    (31) term -> term / . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 53
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    par                            shift and go to state 66

state 43

    (33) term -> term AND . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 53
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    par                            shift and go to state 67

state 44

    (2) instrs -> instrs instr .

    }               reduce using rule 2 (instrs -> instrs instr .)
    ID              reduce using rule 2 (instrs -> instrs instr .)
    WRITE           reduce using rule 2 (instrs -> instrs instr .)
    READ            reduce using rule 2 (instrs -> instrs instr .)
    ;               reduce using rule 2 (instrs -> instrs instr .)
    IF              reduce using rule 2 (instrs -> instrs instr .)
    REPEATE         reduce using rule 2 (instrs -> instrs instr .)
    (               reduce using rule 2 (instrs -> instrs instr .)
    NUM             reduce using rule 2 (instrs -> instrs instr .)
    NOT             reduce using rule 2 (instrs -> instrs instr .)
    END             reduce using rule 2 (instrs -> instrs instr .)
    )               reduce using rule 2 (instrs -> instrs instr .)
    START           reduce using rule 2 (instrs -> instrs instr .)


state 45

    (1) main -> MAIN instrs END .

    $end            reduce using rule 1 (main -> MAIN instrs END .)


state 46

    (18) read -> READ ID .

    ;               reduce using rule 18 (read -> READ ID .)


state 47

    (14) cycle -> REPEATE START . { instrs } UNTIL ( instrs ) END

    {               shift and go to state 68


state 48

    (16) write -> WRITE STR .

    ;               reduce using rule 16 (write -> WRITE STR .)


state 49

    (15) write -> WRITE ID .

    ;               reduce using rule 15 (write -> WRITE ID .)


state 50

    (5) instr -> write endline .

    }               reduce using rule 5 (instr -> write endline .)
    ID              reduce using rule 5 (instr -> write endline .)
    WRITE           reduce using rule 5 (instr -> write endline .)
    READ            reduce using rule 5 (instr -> write endline .)
    ;               reduce using rule 5 (instr -> write endline .)
    IF              reduce using rule 5 (instr -> write endline .)
    REPEATE         reduce using rule 5 (instr -> write endline .)
    (               reduce using rule 5 (instr -> write endline .)
    NUM             reduce using rule 5 (instr -> write endline .)
    NOT             reduce using rule 5 (instr -> write endline .)
    END             reduce using rule 5 (instr -> write endline .)
    START           reduce using rule 5 (instr -> write endline .)
    )               reduce using rule 5 (instr -> write endline .)


state 51

    (13) cond -> IF ( lexpr . ) START instrs START ELSE START instrs END
    (19) lexpr -> lexpr . AND lexpr

    )               shift and go to state 69
    AND             shift and go to state 28


state 52

    (17) atr -> ID = expr .
    (27) expr -> expr . + expr
    (28) expr -> expr . - expr

    ;               reduce using rule 17 (atr -> ID = expr .)
    +               shift and go to state 34
    -               shift and go to state 36


state 53

    (35) par -> ( . expr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

    (               shift and go to state 53
    NUM             shift and go to state 9
    ID              shift and go to state 25
    NOT             shift and go to state 3

    expr                           shift and go to state 70
    par                            shift and go to state 4
    term                           shift and go to state 15

state 54

    (19) lexpr -> lexpr AND lexpr .
    (19) lexpr -> lexpr . AND lexpr

  ! shift/reduce conflict for AND resolved as shift
    }               reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    ID              reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    WRITE           reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    READ            reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    ;               reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    IF              reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    REPEATE         reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    (               reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    NUM             reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    NOT             reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    START           reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    END             reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    )               reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    *               reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    /               reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    %               reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    EQ              reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    LE              reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    GE              reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    >               reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    <               reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    +               reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    -               reduce using rule 19 (lexpr -> lexpr AND lexpr .)
    AND             shift and go to state 28

  ! AND             [ reduce using rule 19 (lexpr -> lexpr AND lexpr .) ]


state 55

    (26) lexpr -> ( lexpr ) .

    AND             reduce using rule 26 (lexpr -> ( lexpr ) .)
    }               reduce using rule 26 (lexpr -> ( lexpr ) .)
    ID              reduce using rule 26 (lexpr -> ( lexpr ) .)
    WRITE           reduce using rule 26 (lexpr -> ( lexpr ) .)
    READ            reduce using rule 26 (lexpr -> ( lexpr ) .)
    ;               reduce using rule 26 (lexpr -> ( lexpr ) .)
    IF              reduce using rule 26 (lexpr -> ( lexpr ) .)
    REPEATE         reduce using rule 26 (lexpr -> ( lexpr ) .)
    (               reduce using rule 26 (lexpr -> ( lexpr ) .)
    NUM             reduce using rule 26 (lexpr -> ( lexpr ) .)
    NOT             reduce using rule 26 (lexpr -> ( lexpr ) .)
    START           reduce using rule 26 (lexpr -> ( lexpr ) .)
    END             reduce using rule 26 (lexpr -> ( lexpr ) .)
    )               reduce using rule 26 (lexpr -> ( lexpr ) .)
    *               reduce using rule 26 (lexpr -> ( lexpr ) .)
    /               reduce using rule 26 (lexpr -> ( lexpr ) .)
    %               reduce using rule 26 (lexpr -> ( lexpr ) .)
    EQ              reduce using rule 26 (lexpr -> ( lexpr ) .)
    LE              reduce using rule 26 (lexpr -> ( lexpr ) .)
    GE              reduce using rule 26 (lexpr -> ( lexpr ) .)
    >               reduce using rule 26 (lexpr -> ( lexpr ) .)
    <               reduce using rule 26 (lexpr -> ( lexpr ) .)
    +               reduce using rule 26 (lexpr -> ( lexpr ) .)
    -               reduce using rule 26 (lexpr -> ( lexpr ) .)


state 56

    (35) par -> ( expr ) .

    *               reduce using rule 35 (par -> ( expr ) .)
    /               reduce using rule 35 (par -> ( expr ) .)
    %               reduce using rule 35 (par -> ( expr ) .)
    AND             reduce using rule 35 (par -> ( expr ) .)
    EQ              reduce using rule 35 (par -> ( expr ) .)
    LE              reduce using rule 35 (par -> ( expr ) .)
    GE              reduce using rule 35 (par -> ( expr ) .)
    >               reduce using rule 35 (par -> ( expr ) .)
    <               reduce using rule 35 (par -> ( expr ) .)
    +               reduce using rule 35 (par -> ( expr ) .)
    -               reduce using rule 35 (par -> ( expr ) .)
    )               reduce using rule 35 (par -> ( expr ) .)
    ID              reduce using rule 35 (par -> ( expr ) .)
    WRITE           reduce using rule 35 (par -> ( expr ) .)
    READ            reduce using rule 35 (par -> ( expr ) .)
    ;               reduce using rule 35 (par -> ( expr ) .)
    IF              reduce using rule 35 (par -> ( expr ) .)
    REPEATE         reduce using rule 35 (par -> ( expr ) .)
    (               reduce using rule 35 (par -> ( expr ) .)
    NUM             reduce using rule 35 (par -> ( expr ) .)
    NOT             reduce using rule 35 (par -> ( expr ) .)
    END             reduce using rule 35 (par -> ( expr ) .)
    }               reduce using rule 35 (par -> ( expr ) .)
    START           reduce using rule 35 (par -> ( expr ) .)


state 57

    (24) lexpr -> expr < expr .
    (27) expr -> expr . + expr
    (28) expr -> expr . - expr

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
    AND             reduce using rule 24 (lexpr -> expr < expr .)
    }               reduce using rule 24 (lexpr -> expr < expr .)
    ID              reduce using rule 24 (lexpr -> expr < expr .)
    WRITE           reduce using rule 24 (lexpr -> expr < expr .)
    READ            reduce using rule 24 (lexpr -> expr < expr .)
    ;               reduce using rule 24 (lexpr -> expr < expr .)
    IF              reduce using rule 24 (lexpr -> expr < expr .)
    REPEATE         reduce using rule 24 (lexpr -> expr < expr .)
    (               reduce using rule 24 (lexpr -> expr < expr .)
    NUM             reduce using rule 24 (lexpr -> expr < expr .)
    NOT             reduce using rule 24 (lexpr -> expr < expr .)
    START           reduce using rule 24 (lexpr -> expr < expr .)
    END             reduce using rule 24 (lexpr -> expr < expr .)
    )               reduce using rule 24 (lexpr -> expr < expr .)
    *               reduce using rule 24 (lexpr -> expr < expr .)
    /               reduce using rule 24 (lexpr -> expr < expr .)
    %               reduce using rule 24 (lexpr -> expr < expr .)
    EQ              reduce using rule 24 (lexpr -> expr < expr .)
    LE              reduce using rule 24 (lexpr -> expr < expr .)
    GE              reduce using rule 24 (lexpr -> expr < expr .)
    >               reduce using rule 24 (lexpr -> expr < expr .)
    <               reduce using rule 24 (lexpr -> expr < expr .)
    +               shift and go to state 34
    -               shift and go to state 36

  ! +               [ reduce using rule 24 (lexpr -> expr < expr .) ]
  ! -               [ reduce using rule 24 (lexpr -> expr < expr .) ]


state 58

    (27) expr -> expr + expr .
    (27) expr -> expr . + expr
    (28) expr -> expr . - expr

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
    EQ              reduce using rule 27 (expr -> expr + expr .)
    LE              reduce using rule 27 (expr -> expr + expr .)
    GE              reduce using rule 27 (expr -> expr + expr .)
    >               reduce using rule 27 (expr -> expr + expr .)
    <               reduce using rule 27 (expr -> expr + expr .)
    )               reduce using rule 27 (expr -> expr + expr .)
    AND             reduce using rule 27 (expr -> expr + expr .)
    END             reduce using rule 27 (expr -> expr + expr .)
    ID              reduce using rule 27 (expr -> expr + expr .)
    WRITE           reduce using rule 27 (expr -> expr + expr .)
    READ            reduce using rule 27 (expr -> expr + expr .)
    ;               reduce using rule 27 (expr -> expr + expr .)
    IF              reduce using rule 27 (expr -> expr + expr .)
    REPEATE         reduce using rule 27 (expr -> expr + expr .)
    (               reduce using rule 27 (expr -> expr + expr .)
    NUM             reduce using rule 27 (expr -> expr + expr .)
    NOT             reduce using rule 27 (expr -> expr + expr .)
    *               reduce using rule 27 (expr -> expr + expr .)
    /               reduce using rule 27 (expr -> expr + expr .)
    %               reduce using rule 27 (expr -> expr + expr .)
    }               reduce using rule 27 (expr -> expr + expr .)
    START           reduce using rule 27 (expr -> expr + expr .)
    +               shift and go to state 34
    -               shift and go to state 36

  ! +               [ reduce using rule 27 (expr -> expr + expr .) ]
  ! -               [ reduce using rule 27 (expr -> expr + expr .) ]


state 59

    (22) lexpr -> expr GE expr .
    (27) expr -> expr . + expr
    (28) expr -> expr . - expr

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
    AND             reduce using rule 22 (lexpr -> expr GE expr .)
    }               reduce using rule 22 (lexpr -> expr GE expr .)
    ID              reduce using rule 22 (lexpr -> expr GE expr .)
    WRITE           reduce using rule 22 (lexpr -> expr GE expr .)
    READ            reduce using rule 22 (lexpr -> expr GE expr .)
    ;               reduce using rule 22 (lexpr -> expr GE expr .)
    IF              reduce using rule 22 (lexpr -> expr GE expr .)
    REPEATE         reduce using rule 22 (lexpr -> expr GE expr .)
    (               reduce using rule 22 (lexpr -> expr GE expr .)
    NUM             reduce using rule 22 (lexpr -> expr GE expr .)
    NOT             reduce using rule 22 (lexpr -> expr GE expr .)
    START           reduce using rule 22 (lexpr -> expr GE expr .)
    END             reduce using rule 22 (lexpr -> expr GE expr .)
    )               reduce using rule 22 (lexpr -> expr GE expr .)
    *               reduce using rule 22 (lexpr -> expr GE expr .)
    /               reduce using rule 22 (lexpr -> expr GE expr .)
    %               reduce using rule 22 (lexpr -> expr GE expr .)
    EQ              reduce using rule 22 (lexpr -> expr GE expr .)
    LE              reduce using rule 22 (lexpr -> expr GE expr .)
    GE              reduce using rule 22 (lexpr -> expr GE expr .)
    >               reduce using rule 22 (lexpr -> expr GE expr .)
    <               reduce using rule 22 (lexpr -> expr GE expr .)
    +               shift and go to state 34
    -               shift and go to state 36

  ! +               [ reduce using rule 22 (lexpr -> expr GE expr .) ]
  ! -               [ reduce using rule 22 (lexpr -> expr GE expr .) ]


state 60

    (28) expr -> expr - expr .
    (27) expr -> expr . + expr
    (28) expr -> expr . - expr

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
    EQ              reduce using rule 28 (expr -> expr - expr .)
    LE              reduce using rule 28 (expr -> expr - expr .)
    GE              reduce using rule 28 (expr -> expr - expr .)
    >               reduce using rule 28 (expr -> expr - expr .)
    <               reduce using rule 28 (expr -> expr - expr .)
    )               reduce using rule 28 (expr -> expr - expr .)
    AND             reduce using rule 28 (expr -> expr - expr .)
    END             reduce using rule 28 (expr -> expr - expr .)
    ID              reduce using rule 28 (expr -> expr - expr .)
    WRITE           reduce using rule 28 (expr -> expr - expr .)
    READ            reduce using rule 28 (expr -> expr - expr .)
    ;               reduce using rule 28 (expr -> expr - expr .)
    IF              reduce using rule 28 (expr -> expr - expr .)
    REPEATE         reduce using rule 28 (expr -> expr - expr .)
    (               reduce using rule 28 (expr -> expr - expr .)
    NUM             reduce using rule 28 (expr -> expr - expr .)
    NOT             reduce using rule 28 (expr -> expr - expr .)
    *               reduce using rule 28 (expr -> expr - expr .)
    /               reduce using rule 28 (expr -> expr - expr .)
    %               reduce using rule 28 (expr -> expr - expr .)
    }               reduce using rule 28 (expr -> expr - expr .)
    START           reduce using rule 28 (expr -> expr - expr .)
    +               shift and go to state 34
    -               shift and go to state 36

  ! +               [ reduce using rule 28 (expr -> expr - expr .) ]
  ! -               [ reduce using rule 28 (expr -> expr - expr .) ]


state 61

    (21) lexpr -> expr LE expr .
    (27) expr -> expr . + expr
    (28) expr -> expr . - expr

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
    AND             reduce using rule 21 (lexpr -> expr LE expr .)
    }               reduce using rule 21 (lexpr -> expr LE expr .)
    ID              reduce using rule 21 (lexpr -> expr LE expr .)
    WRITE           reduce using rule 21 (lexpr -> expr LE expr .)
    READ            reduce using rule 21 (lexpr -> expr LE expr .)
    ;               reduce using rule 21 (lexpr -> expr LE expr .)
    IF              reduce using rule 21 (lexpr -> expr LE expr .)
    REPEATE         reduce using rule 21 (lexpr -> expr LE expr .)
    (               reduce using rule 21 (lexpr -> expr LE expr .)
    NUM             reduce using rule 21 (lexpr -> expr LE expr .)
    NOT             reduce using rule 21 (lexpr -> expr LE expr .)
    START           reduce using rule 21 (lexpr -> expr LE expr .)
    END             reduce using rule 21 (lexpr -> expr LE expr .)
    )               reduce using rule 21 (lexpr -> expr LE expr .)
    *               reduce using rule 21 (lexpr -> expr LE expr .)
    /               reduce using rule 21 (lexpr -> expr LE expr .)
    %               reduce using rule 21 (lexpr -> expr LE expr .)
    EQ              reduce using rule 21 (lexpr -> expr LE expr .)
    LE              reduce using rule 21 (lexpr -> expr LE expr .)
    GE              reduce using rule 21 (lexpr -> expr LE expr .)
    >               reduce using rule 21 (lexpr -> expr LE expr .)
    <               reduce using rule 21 (lexpr -> expr LE expr .)
    +               shift and go to state 34
    -               shift and go to state 36

  ! +               [ reduce using rule 21 (lexpr -> expr LE expr .) ]
  ! -               [ reduce using rule 21 (lexpr -> expr LE expr .) ]


state 62

    (23) lexpr -> expr > expr .
    (27) expr -> expr . + expr
    (28) expr -> expr . - expr

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
    AND             reduce using rule 23 (lexpr -> expr > expr .)
    }               reduce using rule 23 (lexpr -> expr > expr .)
    ID              reduce using rule 23 (lexpr -> expr > expr .)
    WRITE           reduce using rule 23 (lexpr -> expr > expr .)
    READ            reduce using rule 23 (lexpr -> expr > expr .)
    ;               reduce using rule 23 (lexpr -> expr > expr .)
    IF              reduce using rule 23 (lexpr -> expr > expr .)
    REPEATE         reduce using rule 23 (lexpr -> expr > expr .)
    (               reduce using rule 23 (lexpr -> expr > expr .)
    NUM             reduce using rule 23 (lexpr -> expr > expr .)
    NOT             reduce using rule 23 (lexpr -> expr > expr .)
    START           reduce using rule 23 (lexpr -> expr > expr .)
    END             reduce using rule 23 (lexpr -> expr > expr .)
    )               reduce using rule 23 (lexpr -> expr > expr .)
    *               reduce using rule 23 (lexpr -> expr > expr .)
    /               reduce using rule 23 (lexpr -> expr > expr .)
    %               reduce using rule 23 (lexpr -> expr > expr .)
    EQ              reduce using rule 23 (lexpr -> expr > expr .)
    LE              reduce using rule 23 (lexpr -> expr > expr .)
    GE              reduce using rule 23 (lexpr -> expr > expr .)
    >               reduce using rule 23 (lexpr -> expr > expr .)
    <               reduce using rule 23 (lexpr -> expr > expr .)
    +               shift and go to state 34
    -               shift and go to state 36

  ! +               [ reduce using rule 23 (lexpr -> expr > expr .) ]
  ! -               [ reduce using rule 23 (lexpr -> expr > expr .) ]


state 63

    (20) lexpr -> expr EQ expr .
    (27) expr -> expr . + expr
    (28) expr -> expr . - expr

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
    AND             reduce using rule 20 (lexpr -> expr EQ expr .)
    }               reduce using rule 20 (lexpr -> expr EQ expr .)
    ID              reduce using rule 20 (lexpr -> expr EQ expr .)
    WRITE           reduce using rule 20 (lexpr -> expr EQ expr .)
    READ            reduce using rule 20 (lexpr -> expr EQ expr .)
    ;               reduce using rule 20 (lexpr -> expr EQ expr .)
    IF              reduce using rule 20 (lexpr -> expr EQ expr .)
    REPEATE         reduce using rule 20 (lexpr -> expr EQ expr .)
    (               reduce using rule 20 (lexpr -> expr EQ expr .)
    NUM             reduce using rule 20 (lexpr -> expr EQ expr .)
    NOT             reduce using rule 20 (lexpr -> expr EQ expr .)
    START           reduce using rule 20 (lexpr -> expr EQ expr .)
    END             reduce using rule 20 (lexpr -> expr EQ expr .)
    )               reduce using rule 20 (lexpr -> expr EQ expr .)
    *               reduce using rule 20 (lexpr -> expr EQ expr .)
    /               reduce using rule 20 (lexpr -> expr EQ expr .)
    %               reduce using rule 20 (lexpr -> expr EQ expr .)
    EQ              reduce using rule 20 (lexpr -> expr EQ expr .)
    LE              reduce using rule 20 (lexpr -> expr EQ expr .)
    GE              reduce using rule 20 (lexpr -> expr EQ expr .)
    >               reduce using rule 20 (lexpr -> expr EQ expr .)
    <               reduce using rule 20 (lexpr -> expr EQ expr .)
    +               shift and go to state 34
    -               shift and go to state 36

  ! +               [ reduce using rule 20 (lexpr -> expr EQ expr .) ]
  ! -               [ reduce using rule 20 (lexpr -> expr EQ expr .) ]


state 64

    (30) term -> term * par .

    AND             reduce using rule 30 (term -> term * par .)
    *               reduce using rule 30 (term -> term * par .)
    /               reduce using rule 30 (term -> term * par .)
    %               reduce using rule 30 (term -> term * par .)
    EQ              reduce using rule 30 (term -> term * par .)
    LE              reduce using rule 30 (term -> term * par .)
    GE              reduce using rule 30 (term -> term * par .)
    >               reduce using rule 30 (term -> term * par .)
    <               reduce using rule 30 (term -> term * par .)
    +               reduce using rule 30 (term -> term * par .)
    -               reduce using rule 30 (term -> term * par .)
    END             reduce using rule 30 (term -> term * par .)
    ID              reduce using rule 30 (term -> term * par .)
    WRITE           reduce using rule 30 (term -> term * par .)
    READ            reduce using rule 30 (term -> term * par .)
    ;               reduce using rule 30 (term -> term * par .)
    IF              reduce using rule 30 (term -> term * par .)
    REPEATE         reduce using rule 30 (term -> term * par .)
    (               reduce using rule 30 (term -> term * par .)
    NUM             reduce using rule 30 (term -> term * par .)
    NOT             reduce using rule 30 (term -> term * par .)
    )               reduce using rule 30 (term -> term * par .)
    }               reduce using rule 30 (term -> term * par .)
    START           reduce using rule 30 (term -> term * par .)


state 65

    (32) term -> term % par .

    AND             reduce using rule 32 (term -> term % par .)
    *               reduce using rule 32 (term -> term % par .)
    /               reduce using rule 32 (term -> term % par .)
    %               reduce using rule 32 (term -> term % par .)
    EQ              reduce using rule 32 (term -> term % par .)
    LE              reduce using rule 32 (term -> term % par .)
    GE              reduce using rule 32 (term -> term % par .)
    >               reduce using rule 32 (term -> term % par .)
    <               reduce using rule 32 (term -> term % par .)
    +               reduce using rule 32 (term -> term % par .)
    -               reduce using rule 32 (term -> term % par .)
    END             reduce using rule 32 (term -> term % par .)
    ID              reduce using rule 32 (term -> term % par .)
    WRITE           reduce using rule 32 (term -> term % par .)
    READ            reduce using rule 32 (term -> term % par .)
    ;               reduce using rule 32 (term -> term % par .)
    IF              reduce using rule 32 (term -> term % par .)
    REPEATE         reduce using rule 32 (term -> term % par .)
    (               reduce using rule 32 (term -> term % par .)
    NUM             reduce using rule 32 (term -> term % par .)
    NOT             reduce using rule 32 (term -> term % par .)
    )               reduce using rule 32 (term -> term % par .)
    }               reduce using rule 32 (term -> term % par .)
    START           reduce using rule 32 (term -> term % par .)


state 66

    (31) term -> term / par .

    AND             reduce using rule 31 (term -> term / par .)
    *               reduce using rule 31 (term -> term / par .)
    /               reduce using rule 31 (term -> term / par .)
    %               reduce using rule 31 (term -> term / par .)
    EQ              reduce using rule 31 (term -> term / par .)
    LE              reduce using rule 31 (term -> term / par .)
    GE              reduce using rule 31 (term -> term / par .)
    >               reduce using rule 31 (term -> term / par .)
    <               reduce using rule 31 (term -> term / par .)
    +               reduce using rule 31 (term -> term / par .)
    -               reduce using rule 31 (term -> term / par .)
    END             reduce using rule 31 (term -> term / par .)
    ID              reduce using rule 31 (term -> term / par .)
    WRITE           reduce using rule 31 (term -> term / par .)
    READ            reduce using rule 31 (term -> term / par .)
    ;               reduce using rule 31 (term -> term / par .)
    IF              reduce using rule 31 (term -> term / par .)
    REPEATE         reduce using rule 31 (term -> term / par .)
    (               reduce using rule 31 (term -> term / par .)
    NUM             reduce using rule 31 (term -> term / par .)
    NOT             reduce using rule 31 (term -> term / par .)
    )               reduce using rule 31 (term -> term / par .)
    }               reduce using rule 31 (term -> term / par .)
    START           reduce using rule 31 (term -> term / par .)


state 67

    (33) term -> term AND par .

    AND             reduce using rule 33 (term -> term AND par .)
    *               reduce using rule 33 (term -> term AND par .)
    /               reduce using rule 33 (term -> term AND par .)
    %               reduce using rule 33 (term -> term AND par .)
    EQ              reduce using rule 33 (term -> term AND par .)
    LE              reduce using rule 33 (term -> term AND par .)
    GE              reduce using rule 33 (term -> term AND par .)
    >               reduce using rule 33 (term -> term AND par .)
    <               reduce using rule 33 (term -> term AND par .)
    +               reduce using rule 33 (term -> term AND par .)
    -               reduce using rule 33 (term -> term AND par .)
    END             reduce using rule 33 (term -> term AND par .)
    ID              reduce using rule 33 (term -> term AND par .)
    WRITE           reduce using rule 33 (term -> term AND par .)
    READ            reduce using rule 33 (term -> term AND par .)
    ;               reduce using rule 33 (term -> term AND par .)
    IF              reduce using rule 33 (term -> term AND par .)
    REPEATE         reduce using rule 33 (term -> term AND par .)
    (               reduce using rule 33 (term -> term AND par .)
    NUM             reduce using rule 33 (term -> term AND par .)
    NOT             reduce using rule 33 (term -> term AND par .)
    )               reduce using rule 33 (term -> term AND par .)
    }               reduce using rule 33 (term -> term AND par .)
    START           reduce using rule 33 (term -> term AND par .)


state 68

    (14) cycle -> REPEATE START { . instrs } UNTIL ( instrs ) END
    (2) instrs -> . instrs instr
    (3) instrs -> . instr
    (4) instr -> . atr endline
    (5) instr -> . write endline
    (6) instr -> . read endline
    (7) instr -> . endline
    (8) instr -> . cond
    (9) instr -> . cycle
    (10) instr -> . lexpr
    (11) instr -> .
    (17) atr -> . ID = expr
    (15) write -> . WRITE ID
    (16) write -> . WRITE STR
    (18) read -> . READ ID
    (12) endline -> . ;
    (13) cond -> . IF ( lexpr ) START instrs START ELSE START instrs END
    (14) cycle -> . REPEATE START { instrs } UNTIL ( instrs ) END
    (19) lexpr -> . lexpr AND lexpr
    (20) lexpr -> . expr EQ expr
    (21) lexpr -> . expr LE expr
    (22) lexpr -> . expr GE expr
    (23) lexpr -> . expr > expr
    (24) lexpr -> . expr < expr
    (25) lexpr -> . expr
    (26) lexpr -> . ( lexpr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEATE resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    }               reduce using rule 11 (instr -> .)
    ID              shift and go to state 6
    WRITE           shift and go to state 22
    READ            shift and go to state 19
    ;               shift and go to state 18
    IF              shift and go to state 5
    REPEATE         shift and go to state 21
    (               shift and go to state 12
    NUM             shift and go to state 9
    NOT             shift and go to state 3

  ! ID              [ reduce using rule 11 (instr -> .) ]
  ! WRITE           [ reduce using rule 11 (instr -> .) ]
  ! READ            [ reduce using rule 11 (instr -> .) ]
  ! ;               [ reduce using rule 11 (instr -> .) ]
  ! IF              [ reduce using rule 11 (instr -> .) ]
  ! REPEATE         [ reduce using rule 11 (instr -> .) ]
  ! (               [ reduce using rule 11 (instr -> .) ]
  ! NUM             [ reduce using rule 11 (instr -> .) ]
  ! NOT             [ reduce using rule 11 (instr -> .) ]

    par                            shift and go to state 4
    endline                        shift and go to state 20
    instrs                         shift and go to state 71
    cycle                          shift and go to state 17
    lexpr                          shift and go to state 7
    atr                            shift and go to state 8
    cond                           shift and go to state 10
    expr                           shift and go to state 13
    write                          shift and go to state 23
    read                           shift and go to state 11
    instr                          shift and go to state 14
    term                           shift and go to state 15

state 69

    (13) cond -> IF ( lexpr ) . START instrs START ELSE START instrs END

    START           shift and go to state 72


state 70

    (35) par -> ( expr . )
    (27) expr -> expr . + expr
    (28) expr -> expr . - expr

    )               shift and go to state 56
    +               shift and go to state 34
    -               shift and go to state 36


state 71

    (14) cycle -> REPEATE START { instrs . } UNTIL ( instrs ) END
    (2) instrs -> instrs . instr
    (4) instr -> . atr endline
    (5) instr -> . write endline
    (6) instr -> . read endline
    (7) instr -> . endline
    (8) instr -> . cond
    (9) instr -> . cycle
    (10) instr -> . lexpr
    (11) instr -> .
    (17) atr -> . ID = expr
    (15) write -> . WRITE ID
    (16) write -> . WRITE STR
    (18) read -> . READ ID
    (12) endline -> . ;
    (13) cond -> . IF ( lexpr ) START instrs START ELSE START instrs END
    (14) cycle -> . REPEATE START { instrs } UNTIL ( instrs ) END
    (19) lexpr -> . lexpr AND lexpr
    (20) lexpr -> . expr EQ expr
    (21) lexpr -> . expr LE expr
    (22) lexpr -> . expr GE expr
    (23) lexpr -> . expr > expr
    (24) lexpr -> . expr < expr
    (25) lexpr -> . expr
    (26) lexpr -> . ( lexpr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEATE resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    }               shift and go to state 73
    ID              shift and go to state 6
    WRITE           shift and go to state 22
    READ            shift and go to state 19
    ;               shift and go to state 18
    IF              shift and go to state 5
    REPEATE         shift and go to state 21
    (               shift and go to state 12
    NUM             shift and go to state 9
    NOT             shift and go to state 3

  ! }               [ reduce using rule 11 (instr -> .) ]
  ! ID              [ reduce using rule 11 (instr -> .) ]
  ! WRITE           [ reduce using rule 11 (instr -> .) ]
  ! READ            [ reduce using rule 11 (instr -> .) ]
  ! ;               [ reduce using rule 11 (instr -> .) ]
  ! IF              [ reduce using rule 11 (instr -> .) ]
  ! REPEATE         [ reduce using rule 11 (instr -> .) ]
  ! (               [ reduce using rule 11 (instr -> .) ]
  ! NUM             [ reduce using rule 11 (instr -> .) ]
  ! NOT             [ reduce using rule 11 (instr -> .) ]

    par                            shift and go to state 4
    endline                        shift and go to state 20
    cycle                          shift and go to state 17
    lexpr                          shift and go to state 7
    atr                            shift and go to state 8
    cond                           shift and go to state 10
    expr                           shift and go to state 13
    write                          shift and go to state 23
    read                           shift and go to state 11
    instr                          shift and go to state 44
    term                           shift and go to state 15

state 72

    (13) cond -> IF ( lexpr ) START . instrs START ELSE START instrs END
    (2) instrs -> . instrs instr
    (3) instrs -> . instr
    (4) instr -> . atr endline
    (5) instr -> . write endline
    (6) instr -> . read endline
    (7) instr -> . endline
    (8) instr -> . cond
    (9) instr -> . cycle
    (10) instr -> . lexpr
    (11) instr -> .
    (17) atr -> . ID = expr
    (15) write -> . WRITE ID
    (16) write -> . WRITE STR
    (18) read -> . READ ID
    (12) endline -> . ;
    (13) cond -> . IF ( lexpr ) START instrs START ELSE START instrs END
    (14) cycle -> . REPEATE START { instrs } UNTIL ( instrs ) END
    (19) lexpr -> . lexpr AND lexpr
    (20) lexpr -> . expr EQ expr
    (21) lexpr -> . expr LE expr
    (22) lexpr -> . expr GE expr
    (23) lexpr -> . expr > expr
    (24) lexpr -> . expr < expr
    (25) lexpr -> . expr
    (26) lexpr -> . ( lexpr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEATE resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    START           reduce using rule 11 (instr -> .)
    ID              shift and go to state 6
    WRITE           shift and go to state 22
    READ            shift and go to state 19
    ;               shift and go to state 18
    IF              shift and go to state 5
    REPEATE         shift and go to state 21
    (               shift and go to state 12
    NUM             shift and go to state 9
    NOT             shift and go to state 3

  ! ID              [ reduce using rule 11 (instr -> .) ]
  ! WRITE           [ reduce using rule 11 (instr -> .) ]
  ! READ            [ reduce using rule 11 (instr -> .) ]
  ! ;               [ reduce using rule 11 (instr -> .) ]
  ! IF              [ reduce using rule 11 (instr -> .) ]
  ! REPEATE         [ reduce using rule 11 (instr -> .) ]
  ! (               [ reduce using rule 11 (instr -> .) ]
  ! NUM             [ reduce using rule 11 (instr -> .) ]
  ! NOT             [ reduce using rule 11 (instr -> .) ]

    par                            shift and go to state 4
    endline                        shift and go to state 20
    instrs                         shift and go to state 74
    cycle                          shift and go to state 17
    lexpr                          shift and go to state 7
    atr                            shift and go to state 8
    cond                           shift and go to state 10
    expr                           shift and go to state 13
    write                          shift and go to state 23
    read                           shift and go to state 11
    instr                          shift and go to state 14
    term                           shift and go to state 15

state 73

    (14) cycle -> REPEATE START { instrs } . UNTIL ( instrs ) END

    UNTIL           shift and go to state 75


state 74

    (13) cond -> IF ( lexpr ) START instrs . START ELSE START instrs END
    (2) instrs -> instrs . instr
    (4) instr -> . atr endline
    (5) instr -> . write endline
    (6) instr -> . read endline
    (7) instr -> . endline
    (8) instr -> . cond
    (9) instr -> . cycle
    (10) instr -> . lexpr
    (11) instr -> .
    (17) atr -> . ID = expr
    (15) write -> . WRITE ID
    (16) write -> . WRITE STR
    (18) read -> . READ ID
    (12) endline -> . ;
    (13) cond -> . IF ( lexpr ) START instrs START ELSE START instrs END
    (14) cycle -> . REPEATE START { instrs } UNTIL ( instrs ) END
    (19) lexpr -> . lexpr AND lexpr
    (20) lexpr -> . expr EQ expr
    (21) lexpr -> . expr LE expr
    (22) lexpr -> . expr GE expr
    (23) lexpr -> . expr > expr
    (24) lexpr -> . expr < expr
    (25) lexpr -> . expr
    (26) lexpr -> . ( lexpr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

  ! shift/reduce conflict for START resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEATE resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    START           shift and go to state 76
    ID              shift and go to state 6
    WRITE           shift and go to state 22
    READ            shift and go to state 19
    ;               shift and go to state 18
    IF              shift and go to state 5
    REPEATE         shift and go to state 21
    (               shift and go to state 12
    NUM             shift and go to state 9
    NOT             shift and go to state 3

  ! START           [ reduce using rule 11 (instr -> .) ]
  ! ID              [ reduce using rule 11 (instr -> .) ]
  ! WRITE           [ reduce using rule 11 (instr -> .) ]
  ! READ            [ reduce using rule 11 (instr -> .) ]
  ! ;               [ reduce using rule 11 (instr -> .) ]
  ! IF              [ reduce using rule 11 (instr -> .) ]
  ! REPEATE         [ reduce using rule 11 (instr -> .) ]
  ! (               [ reduce using rule 11 (instr -> .) ]
  ! NUM             [ reduce using rule 11 (instr -> .) ]
  ! NOT             [ reduce using rule 11 (instr -> .) ]

    par                            shift and go to state 4
    endline                        shift and go to state 20
    cycle                          shift and go to state 17
    lexpr                          shift and go to state 7
    atr                            shift and go to state 8
    cond                           shift and go to state 10
    expr                           shift and go to state 13
    write                          shift and go to state 23
    read                           shift and go to state 11
    instr                          shift and go to state 44
    term                           shift and go to state 15

state 75

    (14) cycle -> REPEATE START { instrs } UNTIL . ( instrs ) END

    (               shift and go to state 77


state 76

    (13) cond -> IF ( lexpr ) START instrs START . ELSE START instrs END

    ELSE            shift and go to state 78


state 77

    (14) cycle -> REPEATE START { instrs } UNTIL ( . instrs ) END
    (2) instrs -> . instrs instr
    (3) instrs -> . instr
    (4) instr -> . atr endline
    (5) instr -> . write endline
    (6) instr -> . read endline
    (7) instr -> . endline
    (8) instr -> . cond
    (9) instr -> . cycle
    (10) instr -> . lexpr
    (11) instr -> .
    (17) atr -> . ID = expr
    (15) write -> . WRITE ID
    (16) write -> . WRITE STR
    (18) read -> . READ ID
    (12) endline -> . ;
    (13) cond -> . IF ( lexpr ) START instrs START ELSE START instrs END
    (14) cycle -> . REPEATE START { instrs } UNTIL ( instrs ) END
    (19) lexpr -> . lexpr AND lexpr
    (20) lexpr -> . expr EQ expr
    (21) lexpr -> . expr LE expr
    (22) lexpr -> . expr GE expr
    (23) lexpr -> . expr > expr
    (24) lexpr -> . expr < expr
    (25) lexpr -> . expr
    (26) lexpr -> . ( lexpr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEATE resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    )               reduce using rule 11 (instr -> .)
    ID              shift and go to state 6
    WRITE           shift and go to state 22
    READ            shift and go to state 19
    ;               shift and go to state 18
    IF              shift and go to state 5
    REPEATE         shift and go to state 21
    (               shift and go to state 12
    NUM             shift and go to state 9
    NOT             shift and go to state 3

  ! ID              [ reduce using rule 11 (instr -> .) ]
  ! WRITE           [ reduce using rule 11 (instr -> .) ]
  ! READ            [ reduce using rule 11 (instr -> .) ]
  ! ;               [ reduce using rule 11 (instr -> .) ]
  ! IF              [ reduce using rule 11 (instr -> .) ]
  ! REPEATE         [ reduce using rule 11 (instr -> .) ]
  ! (               [ reduce using rule 11 (instr -> .) ]
  ! NUM             [ reduce using rule 11 (instr -> .) ]
  ! NOT             [ reduce using rule 11 (instr -> .) ]

    par                            shift and go to state 4
    endline                        shift and go to state 20
    instrs                         shift and go to state 79
    cycle                          shift and go to state 17
    lexpr                          shift and go to state 7
    atr                            shift and go to state 8
    cond                           shift and go to state 10
    expr                           shift and go to state 13
    write                          shift and go to state 23
    read                           shift and go to state 11
    instr                          shift and go to state 14
    term                           shift and go to state 15

state 78

    (13) cond -> IF ( lexpr ) START instrs START ELSE . START instrs END

    START           shift and go to state 80


state 79

    (14) cycle -> REPEATE START { instrs } UNTIL ( instrs . ) END
    (2) instrs -> instrs . instr
    (4) instr -> . atr endline
    (5) instr -> . write endline
    (6) instr -> . read endline
    (7) instr -> . endline
    (8) instr -> . cond
    (9) instr -> . cycle
    (10) instr -> . lexpr
    (11) instr -> .
    (17) atr -> . ID = expr
    (15) write -> . WRITE ID
    (16) write -> . WRITE STR
    (18) read -> . READ ID
    (12) endline -> . ;
    (13) cond -> . IF ( lexpr ) START instrs START ELSE START instrs END
    (14) cycle -> . REPEATE START { instrs } UNTIL ( instrs ) END
    (19) lexpr -> . lexpr AND lexpr
    (20) lexpr -> . expr EQ expr
    (21) lexpr -> . expr LE expr
    (22) lexpr -> . expr GE expr
    (23) lexpr -> . expr > expr
    (24) lexpr -> . expr < expr
    (25) lexpr -> . expr
    (26) lexpr -> . ( lexpr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

  ! shift/reduce conflict for ) resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEATE resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    )               shift and go to state 81
    ID              shift and go to state 6
    WRITE           shift and go to state 22
    READ            shift and go to state 19
    ;               shift and go to state 18
    IF              shift and go to state 5
    REPEATE         shift and go to state 21
    (               shift and go to state 12
    NUM             shift and go to state 9
    NOT             shift and go to state 3

  ! )               [ reduce using rule 11 (instr -> .) ]
  ! ID              [ reduce using rule 11 (instr -> .) ]
  ! WRITE           [ reduce using rule 11 (instr -> .) ]
  ! READ            [ reduce using rule 11 (instr -> .) ]
  ! ;               [ reduce using rule 11 (instr -> .) ]
  ! IF              [ reduce using rule 11 (instr -> .) ]
  ! REPEATE         [ reduce using rule 11 (instr -> .) ]
  ! (               [ reduce using rule 11 (instr -> .) ]
  ! NUM             [ reduce using rule 11 (instr -> .) ]
  ! NOT             [ reduce using rule 11 (instr -> .) ]

    par                            shift and go to state 4
    endline                        shift and go to state 20
    cycle                          shift and go to state 17
    lexpr                          shift and go to state 7
    atr                            shift and go to state 8
    cond                           shift and go to state 10
    expr                           shift and go to state 13
    write                          shift and go to state 23
    read                           shift and go to state 11
    instr                          shift and go to state 44
    term                           shift and go to state 15

state 80

    (13) cond -> IF ( lexpr ) START instrs START ELSE START . instrs END
    (2) instrs -> . instrs instr
    (3) instrs -> . instr
    (4) instr -> . atr endline
    (5) instr -> . write endline
    (6) instr -> . read endline
    (7) instr -> . endline
    (8) instr -> . cond
    (9) instr -> . cycle
    (10) instr -> . lexpr
    (11) instr -> .
    (17) atr -> . ID = expr
    (15) write -> . WRITE ID
    (16) write -> . WRITE STR
    (18) read -> . READ ID
    (12) endline -> . ;
    (13) cond -> . IF ( lexpr ) START instrs START ELSE START instrs END
    (14) cycle -> . REPEATE START { instrs } UNTIL ( instrs ) END
    (19) lexpr -> . lexpr AND lexpr
    (20) lexpr -> . expr EQ expr
    (21) lexpr -> . expr LE expr
    (22) lexpr -> . expr GE expr
    (23) lexpr -> . expr > expr
    (24) lexpr -> . expr < expr
    (25) lexpr -> . expr
    (26) lexpr -> . ( lexpr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEATE resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    END             reduce using rule 11 (instr -> .)
    ID              shift and go to state 6
    WRITE           shift and go to state 22
    READ            shift and go to state 19
    ;               shift and go to state 18
    IF              shift and go to state 5
    REPEATE         shift and go to state 21
    (               shift and go to state 12
    NUM             shift and go to state 9
    NOT             shift and go to state 3

  ! ID              [ reduce using rule 11 (instr -> .) ]
  ! WRITE           [ reduce using rule 11 (instr -> .) ]
  ! READ            [ reduce using rule 11 (instr -> .) ]
  ! ;               [ reduce using rule 11 (instr -> .) ]
  ! IF              [ reduce using rule 11 (instr -> .) ]
  ! REPEATE         [ reduce using rule 11 (instr -> .) ]
  ! (               [ reduce using rule 11 (instr -> .) ]
  ! NUM             [ reduce using rule 11 (instr -> .) ]
  ! NOT             [ reduce using rule 11 (instr -> .) ]

    par                            shift and go to state 4
    endline                        shift and go to state 20
    instrs                         shift and go to state 82
    cycle                          shift and go to state 17
    lexpr                          shift and go to state 7
    atr                            shift and go to state 8
    cond                           shift and go to state 10
    expr                           shift and go to state 13
    write                          shift and go to state 23
    read                           shift and go to state 11
    instr                          shift and go to state 14
    term                           shift and go to state 15

state 81

    (14) cycle -> REPEATE START { instrs } UNTIL ( instrs ) . END

    END             shift and go to state 83


state 82

    (13) cond -> IF ( lexpr ) START instrs START ELSE START instrs . END
    (2) instrs -> instrs . instr
    (4) instr -> . atr endline
    (5) instr -> . write endline
    (6) instr -> . read endline
    (7) instr -> . endline
    (8) instr -> . cond
    (9) instr -> . cycle
    (10) instr -> . lexpr
    (11) instr -> .
    (17) atr -> . ID = expr
    (15) write -> . WRITE ID
    (16) write -> . WRITE STR
    (18) read -> . READ ID
    (12) endline -> . ;
    (13) cond -> . IF ( lexpr ) START instrs START ELSE START instrs END
    (14) cycle -> . REPEATE START { instrs } UNTIL ( instrs ) END
    (19) lexpr -> . lexpr AND lexpr
    (20) lexpr -> . expr EQ expr
    (21) lexpr -> . expr LE expr
    (22) lexpr -> . expr GE expr
    (23) lexpr -> . expr > expr
    (24) lexpr -> . expr < expr
    (25) lexpr -> . expr
    (26) lexpr -> . ( lexpr )
    (27) expr -> . expr + expr
    (28) expr -> . expr - expr
    (29) expr -> . term
    (30) term -> . term * par
    (31) term -> . term / par
    (32) term -> . term % par
    (33) term -> . term AND par
    (34) term -> . par
    (35) par -> . ( expr )
    (36) par -> . NUM
    (37) par -> . ID
    (38) par -> . NOT lexpr

  ! shift/reduce conflict for END resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEATE resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    END             shift and go to state 84
    ID              shift and go to state 6
    WRITE           shift and go to state 22
    READ            shift and go to state 19
    ;               shift and go to state 18
    IF              shift and go to state 5
    REPEATE         shift and go to state 21
    (               shift and go to state 12
    NUM             shift and go to state 9
    NOT             shift and go to state 3

  ! END             [ reduce using rule 11 (instr -> .) ]
  ! ID              [ reduce using rule 11 (instr -> .) ]
  ! WRITE           [ reduce using rule 11 (instr -> .) ]
  ! READ            [ reduce using rule 11 (instr -> .) ]
  ! ;               [ reduce using rule 11 (instr -> .) ]
  ! IF              [ reduce using rule 11 (instr -> .) ]
  ! REPEATE         [ reduce using rule 11 (instr -> .) ]
  ! (               [ reduce using rule 11 (instr -> .) ]
  ! NUM             [ reduce using rule 11 (instr -> .) ]
  ! NOT             [ reduce using rule 11 (instr -> .) ]

    par                            shift and go to state 4
    endline                        shift and go to state 20
    cycle                          shift and go to state 17
    lexpr                          shift and go to state 7
    atr                            shift and go to state 8
    cond                           shift and go to state 10
    expr                           shift and go to state 13
    write                          shift and go to state 23
    read                           shift and go to state 11
    instr                          shift and go to state 44
    term                           shift and go to state 15

state 83

    (14) cycle -> REPEATE START { instrs } UNTIL ( instrs ) END .

    START           reduce using rule 14 (cycle -> REPEATE START { instrs } UNTIL ( instrs ) END .)
    ID              reduce using rule 14 (cycle -> REPEATE START { instrs } UNTIL ( instrs ) END .)
    WRITE           reduce using rule 14 (cycle -> REPEATE START { instrs } UNTIL ( instrs ) END .)
    READ            reduce using rule 14 (cycle -> REPEATE START { instrs } UNTIL ( instrs ) END .)
    ;               reduce using rule 14 (cycle -> REPEATE START { instrs } UNTIL ( instrs ) END .)
    IF              reduce using rule 14 (cycle -> REPEATE START { instrs } UNTIL ( instrs ) END .)
    REPEATE         reduce using rule 14 (cycle -> REPEATE START { instrs } UNTIL ( instrs ) END .)
    (               reduce using rule 14 (cycle -> REPEATE START { instrs } UNTIL ( instrs ) END .)
    NUM             reduce using rule 14 (cycle -> REPEATE START { instrs } UNTIL ( instrs ) END .)
    NOT             reduce using rule 14 (cycle -> REPEATE START { instrs } UNTIL ( instrs ) END .)
    )               reduce using rule 14 (cycle -> REPEATE START { instrs } UNTIL ( instrs ) END .)
    }               reduce using rule 14 (cycle -> REPEATE START { instrs } UNTIL ( instrs ) END .)
    END             reduce using rule 14 (cycle -> REPEATE START { instrs } UNTIL ( instrs ) END .)


state 84

    (13) cond -> IF ( lexpr ) START instrs START ELSE START instrs END .

    }               reduce using rule 13 (cond -> IF ( lexpr ) START instrs START ELSE START instrs END .)
    ID              reduce using rule 13 (cond -> IF ( lexpr ) START instrs START ELSE START instrs END .)
    WRITE           reduce using rule 13 (cond -> IF ( lexpr ) START instrs START ELSE START instrs END .)
    READ            reduce using rule 13 (cond -> IF ( lexpr ) START instrs START ELSE START instrs END .)
    ;               reduce using rule 13 (cond -> IF ( lexpr ) START instrs START ELSE START instrs END .)
    IF              reduce using rule 13 (cond -> IF ( lexpr ) START instrs START ELSE START instrs END .)
    REPEATE         reduce using rule 13 (cond -> IF ( lexpr ) START instrs START ELSE START instrs END .)
    (               reduce using rule 13 (cond -> IF ( lexpr ) START instrs START ELSE START instrs END .)
    NUM             reduce using rule 13 (cond -> IF ( lexpr ) START instrs START ELSE START instrs END .)
    NOT             reduce using rule 13 (cond -> IF ( lexpr ) START instrs START ELSE START instrs END .)
    END             reduce using rule 13 (cond -> IF ( lexpr ) START instrs START ELSE START instrs END .)
    )               reduce using rule 13 (cond -> IF ( lexpr ) START instrs START ELSE START instrs END .)
    START           reduce using rule 13 (cond -> IF ( lexpr ) START instrs START ELSE START instrs END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 2 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 2 resolved as shift
WARNING: shift/reduce conflict for READ in state 2 resolved as shift
WARNING: shift/reduce conflict for ; in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for REPEATE in state 2 resolved as shift
WARNING: shift/reduce conflict for ( in state 2 resolved as shift
WARNING: shift/reduce conflict for NUM in state 2 resolved as shift
WARNING: shift/reduce conflict for NOT in state 2 resolved as shift
WARNING: shift/reduce conflict for EQ in state 13 resolved as shift
WARNING: shift/reduce conflict for LE in state 13 resolved as shift
WARNING: shift/reduce conflict for GE in state 13 resolved as shift
WARNING: shift/reduce conflict for > in state 13 resolved as shift
WARNING: shift/reduce conflict for < in state 13 resolved as shift
WARNING: shift/reduce conflict for + in state 13 resolved as shift
WARNING: shift/reduce conflict for - in state 13 resolved as shift
WARNING: shift/reduce conflict for * in state 15 resolved as shift
WARNING: shift/reduce conflict for / in state 15 resolved as shift
WARNING: shift/reduce conflict for % in state 15 resolved as shift
WARNING: shift/reduce conflict for AND in state 15 resolved as shift
WARNING: shift/reduce conflict for END in state 16 resolved as shift
WARNING: shift/reduce conflict for ID in state 16 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 16 resolved as shift
WARNING: shift/reduce conflict for READ in state 16 resolved as shift
WARNING: shift/reduce conflict for ; in state 16 resolved as shift
WARNING: shift/reduce conflict for IF in state 16 resolved as shift
WARNING: shift/reduce conflict for REPEATE in state 16 resolved as shift
WARNING: shift/reduce conflict for ( in state 16 resolved as shift
WARNING: shift/reduce conflict for NUM in state 16 resolved as shift
WARNING: shift/reduce conflict for NOT in state 16 resolved as shift
WARNING: shift/reduce conflict for AND in state 24 resolved as shift
WARNING: shift/reduce conflict for ) in state 32 resolved as shift
WARNING: shift/reduce conflict for AND in state 54 resolved as shift
WARNING: shift/reduce conflict for + in state 57 resolved as shift
WARNING: shift/reduce conflict for - in state 57 resolved as shift
WARNING: shift/reduce conflict for + in state 58 resolved as shift
WARNING: shift/reduce conflict for - in state 58 resolved as shift
WARNING: shift/reduce conflict for + in state 59 resolved as shift
WARNING: shift/reduce conflict for - in state 59 resolved as shift
WARNING: shift/reduce conflict for + in state 60 resolved as shift
WARNING: shift/reduce conflict for - in state 60 resolved as shift
WARNING: shift/reduce conflict for + in state 61 resolved as shift
WARNING: shift/reduce conflict for - in state 61 resolved as shift
WARNING: shift/reduce conflict for + in state 62 resolved as shift
WARNING: shift/reduce conflict for - in state 62 resolved as shift
WARNING: shift/reduce conflict for + in state 63 resolved as shift
WARNING: shift/reduce conflict for - in state 63 resolved as shift
WARNING: shift/reduce conflict for ID in state 68 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 68 resolved as shift
WARNING: shift/reduce conflict for READ in state 68 resolved as shift
WARNING: shift/reduce conflict for ; in state 68 resolved as shift
WARNING: shift/reduce conflict for IF in state 68 resolved as shift
WARNING: shift/reduce conflict for REPEATE in state 68 resolved as shift
WARNING: shift/reduce conflict for ( in state 68 resolved as shift
WARNING: shift/reduce conflict for NUM in state 68 resolved as shift
WARNING: shift/reduce conflict for NOT in state 68 resolved as shift
WARNING: shift/reduce conflict for } in state 71 resolved as shift
WARNING: shift/reduce conflict for ID in state 71 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 71 resolved as shift
WARNING: shift/reduce conflict for READ in state 71 resolved as shift
WARNING: shift/reduce conflict for ; in state 71 resolved as shift
WARNING: shift/reduce conflict for IF in state 71 resolved as shift
WARNING: shift/reduce conflict for REPEATE in state 71 resolved as shift
WARNING: shift/reduce conflict for ( in state 71 resolved as shift
WARNING: shift/reduce conflict for NUM in state 71 resolved as shift
WARNING: shift/reduce conflict for NOT in state 71 resolved as shift
WARNING: shift/reduce conflict for ID in state 72 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 72 resolved as shift
WARNING: shift/reduce conflict for READ in state 72 resolved as shift
WARNING: shift/reduce conflict for ; in state 72 resolved as shift
WARNING: shift/reduce conflict for IF in state 72 resolved as shift
WARNING: shift/reduce conflict for REPEATE in state 72 resolved as shift
WARNING: shift/reduce conflict for ( in state 72 resolved as shift
WARNING: shift/reduce conflict for NUM in state 72 resolved as shift
WARNING: shift/reduce conflict for NOT in state 72 resolved as shift
WARNING: shift/reduce conflict for START in state 74 resolved as shift
WARNING: shift/reduce conflict for ID in state 74 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 74 resolved as shift
WARNING: shift/reduce conflict for READ in state 74 resolved as shift
WARNING: shift/reduce conflict for ; in state 74 resolved as shift
WARNING: shift/reduce conflict for IF in state 74 resolved as shift
WARNING: shift/reduce conflict for REPEATE in state 74 resolved as shift
WARNING: shift/reduce conflict for ( in state 74 resolved as shift
WARNING: shift/reduce conflict for NUM in state 74 resolved as shift
WARNING: shift/reduce conflict for NOT in state 74 resolved as shift
WARNING: shift/reduce conflict for ID in state 77 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 77 resolved as shift
WARNING: shift/reduce conflict for READ in state 77 resolved as shift
WARNING: shift/reduce conflict for ; in state 77 resolved as shift
WARNING: shift/reduce conflict for IF in state 77 resolved as shift
WARNING: shift/reduce conflict for REPEATE in state 77 resolved as shift
WARNING: shift/reduce conflict for ( in state 77 resolved as shift
WARNING: shift/reduce conflict for NUM in state 77 resolved as shift
WARNING: shift/reduce conflict for NOT in state 77 resolved as shift
WARNING: shift/reduce conflict for ) in state 79 resolved as shift
WARNING: shift/reduce conflict for ID in state 79 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 79 resolved as shift
WARNING: shift/reduce conflict for READ in state 79 resolved as shift
WARNING: shift/reduce conflict for ; in state 79 resolved as shift
WARNING: shift/reduce conflict for IF in state 79 resolved as shift
WARNING: shift/reduce conflict for REPEATE in state 79 resolved as shift
WARNING: shift/reduce conflict for ( in state 79 resolved as shift
WARNING: shift/reduce conflict for NUM in state 79 resolved as shift
WARNING: shift/reduce conflict for NOT in state 79 resolved as shift
WARNING: shift/reduce conflict for ID in state 80 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 80 resolved as shift
WARNING: shift/reduce conflict for READ in state 80 resolved as shift
WARNING: shift/reduce conflict for ; in state 80 resolved as shift
WARNING: shift/reduce conflict for IF in state 80 resolved as shift
WARNING: shift/reduce conflict for REPEATE in state 80 resolved as shift
WARNING: shift/reduce conflict for ( in state 80 resolved as shift
WARNING: shift/reduce conflict for NUM in state 80 resolved as shift
WARNING: shift/reduce conflict for NOT in state 80 resolved as shift
WARNING: shift/reduce conflict for END in state 82 resolved as shift
WARNING: shift/reduce conflict for ID in state 82 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 82 resolved as shift
WARNING: shift/reduce conflict for READ in state 82 resolved as shift
WARNING: shift/reduce conflict for ; in state 82 resolved as shift
WARNING: shift/reduce conflict for IF in state 82 resolved as shift
WARNING: shift/reduce conflict for REPEATE in state 82 resolved as shift
WARNING: shift/reduce conflict for ( in state 82 resolved as shift
WARNING: shift/reduce conflict for NUM in state 82 resolved as shift
WARNING: shift/reduce conflict for NOT in state 82 resolved as shift
